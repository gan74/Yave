cmake_minimum_required(VERSION 3.11)
project(yave)

function(enable_unity_build UB_SUFFIX SOURCE_VARIABLE_NAME)
    message("Using unity build for target ${UB_SUFFIX}")
    set(FILES ${${SOURCE_VARIABLE_NAME}})

    # Exclude all translation units from compilation
    set_source_files_properties(${FILES} PROPERTIES HEADER_FILE_ONLY true)

    # Generate a unique filename for the unity build translation unit
    set(UNIT_BUILD_FILE ${CMAKE_CURRENT_BINARY_DIR}/blob_${UB_SUFFIX}.cpp)
    file(WRITE ${UNIT_BUILD_FILE} "// Unity Build generated by CMake\n")

    # Add include statement for each translation unit
    foreach(SOURCE_FILE ${FILES})
        get_filename_component(FILE_EXT "${SOURCE_FILE}" EXT)
        if(NOT "${FILE_EXT}" MATCHES "\.h(pp)?")
            file(APPEND ${UNIT_BUILD_FILE} "#include <${SOURCE_FILE}>\n")
        endif()
    endforeach(SOURCE_FILE)

    # Complement list of translation units with the name of ub
    set(${SOURCE_VARIABLE_NAME} ${${SOURCE_VARIABLE_NAME}} ${UNIT_BUILD_FILE} PARENT_SCOPE)
endfunction(enable_unity_build)


option(YAVE_BUILD_YAVE "Build yave" ON)
option(YAVE_BUILD_EDITOR "Build editor" ON)
option(YAVE_BUILD_SHARED "Build as shared library" OFF)
option(YAVE_UNITY_BUILD "Force unity build" OFF)



# Shitty hack to use lld when using MinGW to avoid long link times
if(MINGW)
    option(YAVE_USE_LLD "Use LLD" OFF)
    if(YAVE_USE_LLD)
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fuse-ld=lld")
        set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fuse-ld=lld")
        message("Using LLD instead of MinGW linker")
    endif()
endif()

find_library(Vulkan REQUIRED)

# Another shitty hack to locate vulkan SDK if CMake fails
if(NOT "${Vulkan_INCLUDE_DIRS}")
    file(TO_CMAKE_PATH $ENV{VULKAN_SDK} Vulkan_SDK_Dir)
    set(Vulkan_INCLUDE_DIRS ${Vulkan_SDK_Dir}/Include)
    set(Vulkan_LIBRARY ${Vulkan_SDK_Dir}/Lib/vulkan-1.lib)
endif()


# add y subtree
add_subdirectory(y)

add_subdirectory(external/spirv_cross)

# setup includes
include_directories(${y_SOURCE_DIR})
include_directories(${yave_SOURCE_DIR})
include_directories(${Vulkan_INCLUDE_DIRS})
include_directories(external)

set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_CXX_STANDARD 17)


# Yave's core file
file(GLOB_RECURSE YAVE_FILES
        "yave/*.h"
        "yave/*.cpp"
    )

file(GLOB_RECURSE SQLITE_FILES
        "external/sqlite/*.h"
        "external/sqlite/*.c"
    )

# Editor files
file(GLOB_RECURSE EDITOR_FILES
        "editor/*.cpp"
        "editor/*.h"
    )

file(GLOB_RECURSE EDITOR_EXTERNAL_FILES
        "external/imgui/*.cpp"
        "external/imgui/*.h"

        "external/tinygltf/*.hpp"
        "external/tinygltf/*.h"
    )

# Shader files
file(GLOB_RECURSE SHADER_FILES
        "shaders/*.frag"
        "shaders/*.vert"
        "shaders/*.geom"
        "shaders/*.comp"
    )

# Shader libs, they are here so the IDE can find them
file(GLOB_RECURSE SHADER_LIBS
        "shaders/*.glsl"
    )


if(CMAKE_BUILD_TYPE STREQUAL Release OR YAVE_UNITY_BUILD)
    enable_unity_build(yave YAVE_FILES)
endif()



if(YAVE_BUILD_YAVE)
    add_library(sqlite3 STATIC ${SQLITE_FILES})

    if(YAVE_BUILD_SHARED)
        add_library(yave SHARED ${YAVE_FILES} ${SHADER_FILES} ${SHADER_LIB_FILES})
    else()
        add_library(yave STATIC ${YAVE_FILES} ${SHADER_FILES} ${SHADER_LIB_FILES})
    endif()

    target_link_libraries(yave ${Vulkan_LIBRARY})
    target_link_libraries(yave y spirv-cross-core sqlite3)

    if(NOT MSVC)
        target_link_libraries(yave stdc++fs)
    endif()

    add_custom_target(shaders COMMAND glslc -c ${SHADER_FILES})
    add_dependencies(yave shaders)
endif()

if(YAVE_BUILD_EDITOR)
    add_executable(editor ${EDITOR_FILES} ${EDITOR_EXTERNAL_FILES})

    target_link_libraries(editor yave)
endif()

