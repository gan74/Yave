#version 460

#extension GL_EXT_ray_query : enable

#include "lib/utils.glsl"
#include "lib/noise.glsl"
#include "lib/gbuffer.glsl"


// -------------------------------- DEFINES --------------------------------

#define SAMPLE_BUFFER_SIZE 256

// -------------------------------- I/O --------------------------------


layout(local_size_x = 8, local_size_y = 8) in;

layout(r8, set = 0, binding = 0) uniform writeonly image2D out_ao;

layout(set = 0, binding = 1) uniform sampler2D in_depth;
layout(set = 0, binding = 2) uniform sampler2D in_rt1;

layout(set = 0, binding = 3) uniform CameraData {
    Camera camera;
};

layout(set = 0, binding = 4) uniform SampleDirData {
    vec4 sample_dirs[SAMPLE_BUFFER_SIZE];
};

layout(set = 0, binding = 5) uniform accelerationStructureEXT tlas;


const uint sample_count = 64;
const float max_dist = 1.0;


vec3 compute_sample_dir(vec3 normal, uint i) {
    const vec3 s = sample_dirs[i % SAMPLE_BUFFER_SIZE].xyz;
    return dot(normal, s) < 0.0 ? -s : s;
}


void main() {
    const ivec2 coord = ivec2(gl_GlobalInvocationID.xy * 2);
    const ivec2 image_size = textureSize(in_depth, 0).xy;

    if(any(greaterThan(coord, image_size))) {
        return;
    }

    const float depth = texelFetch(in_depth, coord, 0).x;

    float ao = 0;
    if(!is_OOB(depth)) {
        const vec2 uv = (coord + 0.5) / vec2(image_size);
        const vec3 world_pos = unproject(uv, depth, camera.inv_view_proj);
        const vec3 normal = read_gbuffer(vec4(0.0), texelFetch(in_rt1, coord, 0)).normal;

        const uint sample_index_offset = hash_1_2(gl_GlobalInvocationID.xy);

        for(uint i = 0; i != sample_count; ++i) {
            const vec3 sample_dir = compute_sample_dir(normal, i + sample_index_offset);

            rayQueryEXT query;
            rayQueryInitializeEXT(query, tlas, gl_RayFlagsTerminateOnFirstHitEXT, 0xFF, world_pos, 0.01, sample_dir, max_dist);
            rayQueryProceedEXT(query);

            if(rayQueryGetIntersectionTypeEXT(query, true) != gl_RayQueryCommittedIntersectionNoneEXT) {
                ao += 1.0;
            }
        }

        ao = 1.0 - sqr(ao / sample_count);
    }

    imageStore(out_ao, ivec2(gl_GlobalInvocationID.xy), vec4(ao));
}
